{"nodes": [{"id": "0", "type": "val", "name": "input_grid", "val": "[[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n [0 0 2 2 2 2 2 2 2 2 2 2 2 2 0]\n [0 0 2 0 2 2 2 2 0 2 2 2 0 2 0]\n [0 0 2 0 0 2 2 0 0 2 2 2 2 2 0]\n [0 0 2 2 0 0 2 2 0 2 2 2 2 2 0]\n [0 0 2 2 2 2 2 2 2 2 2 2 2 2 0]\n [0 0 2 2 2 2 2 2 2 2 2 2 2 2 0]\n [0 0 2 2 2 2 2 2 2 0 0 0 2 2 0]\n [0 0 2 2 2 2 2 2 2 2 2 2 2 2 0]\n [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n [0 1 1 1 0 0 0 0 2 3 3 0 0 0 0]\n [0 1 2 1 0 0 0 0 2 2 3 0 0 0 0]\n [0 1 1 1 0 0 0 0 2 3 3 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0 0 8 8 2 0]\n [0 0 0 4 2 4 0 0 0 0 0 8 2 2 0]\n [0 0 0 4 2 4 0 0 0 0 0 2 2 8 0]\n [0 0 0 4 2 4 0 0 0 0 0 0 0 0 0]]"}, {"id": "1", "type": "stmt", "val": "coordinates = `return all left top coordinates of 3x3 grids in the grid`(input_grid)"}, {"id": "2", "type": "val", "name": "coordinates", "val": "[(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9), (0, 10), (0, 11), (0, 12), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (1, 10), (1, 11), (1, 12), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9), (2, 10), (2, 11), (2, 12), (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9), (3, 10), (3, 11), (3, 12), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9), (4, 10), (4, 11), (4, 12), (5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9), (5, 10), (5, 11), (5, 12), (6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9), (6, 10), (6, 11), (6, 12), (7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), (7, 9), (7, 10), (7, 11), (7, 12), (8, 0), (8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), (8, 8), (8, 9), (8, 10), (8, 11), (8, 12), (9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), (9, 7), (9, 8), (9, 9), (9, 10), (9, 11), (9, 12), (10, 0), (10, 1), (10, 2), (10, 3), (10, 4), (10, 5), (10, 6), (10, 7), (10, 8), (10, 9), (10, 10), (10, 11), (10, 12), (11, 0), (11, 1), (11, 2), (11, 3), (11, 4), (11, 5), (11, 6), (11, 7), (11, 8), (11, 9), (11, 10), (11, 11), (11, 12), (12, 0), (12, 1), (12, 2), (12, 3), (12, 4), (12, 5), (12, 6), (12, 7), (12, 8), (12, 9), (12, 10), (12, 11), (12, 12), (13, 0), (13, 1), (13, 2), (13, 3), (13, 4), (13, 5), (13, 6), (13, 7), (13, 8), (13, 9), (13, 10), (13, 11), (13, 12), (14, 0), (14, 1), (14, 2), (14, 3), (14, 4), (14, 5), (14, 6), (14, 7), (14, 8), (14, 9), (14, 10), (14, 11), (14, 12), (15, 0), (15, 1), (15, 2), (15, 3), (15, 4), (15, 5), (15, 6), (15, 7), (15, 8), (15, 9), (15, 10), (15, 11), (15, 12), (16, 0), (16, 1), (16, 2), (16, 3), (16, 4), (16, 5), (16, 6), (16, 7), (16, 8), (16, 9), (16, 10), (16, 11), (16, 12)]"}, {"id": "3", "type": "stmt", "val": "squares_coordinates = `find 3x3 grids which only has only two color, and none of them is black`(coordinates, input_grid)"}, {"id": "4", "type": "val", "name": "squares_coordinates", "val": "[(11, 1), (11, 8), (15, 11), (16, 3)]"}, {"id": "5", "type": "stmt", "val": "squares = `copy the 3x3 small grid from the grid according to the coordinates, return a list of np.array`(input_grid, squares_coordinates)"}, {"id": "7", "type": "stmt", "val": "input_grid = `paint 3x3 grid to black according to the list of coordinates`(input_grid, squares_coordinates)"}, {"id": "8", "type": "val", "name": "input_grid", "val": "[[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n [0 0 2 2 2 2 2 2 2 2 2 2 2 2 0]\n [0 0 2 0 2 2 2 2 0 2 2 2 0 2 0]\n [0 0 2 0 0 2 2 0 0 2 2 2 2 2 0]\n [0 0 2 2 0 0 2 2 0 2 2 2 2 2 0]\n [0 0 2 2 2 2 2 2 2 2 2 2 2 2 0]\n [0 0 2 2 2 2 2 2 2 2 2 2 2 2 0]\n [0 0 2 2 2 2 2 2 2 0 0 0 2 2 0]\n [0 0 2 2 2 2 2 2 2 2 2 2 2 2 0]\n [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]"}, {"id": "9", "type": "stmt", "val": "(top_left, bottom_right) = `find the red shape in the grid`(input_grid)"}, {"id": "10", "type": "val", "name": "top_left", "val": "(1, 2)"}, {"id": "11", "type": "val", "name": "bottom_right", "val": "(8, 13)"}, {"id": "12", "type": "stmt", "val": "output_grid = `extract red shape according to the top_left and bottom_right coordinate`(input_grid, top_left, bottom_right)"}, {"id": "13", "type": "val", "name": "output_grid", "val": "[[2 2 2 2 2 2 2 2 2 2 2 2]\n [2 0 2 2 2 2 0 2 2 2 0 2]\n [2 0 0 2 2 0 0 2 2 2 2 2]\n [2 2 0 0 2 2 0 2 2 2 2 2]\n [2 2 2 2 2 2 2 2 2 2 2 2]\n [2 2 2 2 2 2 2 2 2 2 2 2]\n [2 2 2 2 2 2 2 0 0 0 2 2]\n [2 2 2 2 2 2 2 2 2 2 2 2]]"}, {"id": "14", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "15", "type": "val", "name": "x", "val": "0"}, {"id": "16", "type": "val", "name": "y", "val": "0"}, {"id": "18", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "19", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "21", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "22", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "24", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "25", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "27", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "28", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "30", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "31", "type": "val", "name": "y", "val": "1"}, {"id": "33", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "34", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "36", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "37", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "39", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "40", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "42", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "43", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "45", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "46", "type": "val", "name": "y", "val": "2"}, {"id": "48", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "49", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "51", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "52", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "54", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "55", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "57", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "58", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "60", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "61", "type": "val", "name": "y", "val": "3"}, {"id": "63", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "64", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "66", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "67", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "69", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "70", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "72", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "73", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "75", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "76", "type": "val", "name": "y", "val": "4"}, {"id": "78", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "79", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "81", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "82", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "84", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "85", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "87", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "88", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "90", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "91", "type": "val", "name": "y", "val": "5"}, {"id": "93", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "94", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "96", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "97", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "99", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "100", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "102", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "103", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "105", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "106", "type": "val", "name": "y", "val": "6"}, {"id": "108", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "109", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "111", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "112", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "114", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "115", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "117", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "118", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "120", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "121", "type": "val", "name": "y", "val": "7"}, {"id": "123", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "124", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "126", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "127", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "129", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "130", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "132", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "133", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "135", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "136", "type": "val", "name": "y", "val": "8"}, {"id": "138", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "139", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "141", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "142", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "144", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "145", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "147", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "148", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "150", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "151", "type": "val", "name": "y", "val": "9"}, {"id": "153", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "154", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "156", "type": "val", "name": "output_grid", "val": "[[2 2 2 2 2 2 2 2 2 1 1 1]\n [2 0 2 2 2 2 0 2 2 1 2 1]\n [2 0 0 2 2 0 0 2 2 1 1 1]\n [2 2 0 0 2 2 0 2 2 2 2 2]\n [2 2 2 2 2 2 2 2 2 2 2 2]\n [2 2 2 2 2 2 2 2 2 2 2 2]\n [2 2 2 2 2 2 2 0 0 0 2 2]\n [2 2 2 2 2 2 2 2 2 2 2 2]]"}, {"id": "158", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "159", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "161", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "162", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "164", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "165", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "167", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "168", "type": "val", "name": "x", "val": "1"}, {"id": "169", "type": "val", "name": "y", "val": "0"}, {"id": "171", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "172", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "174", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "175", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "177", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "178", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "180", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "181", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "183", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "184", "type": "val", "name": "y", "val": "1"}, {"id": "186", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "187", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "189", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "190", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "192", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "193", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "195", "type": "val", "name": "output_grid", "val": "[[2 2 2 2 2 2 2 2 2 1 1 1]\n [2 2 8 8 2 2 0 2 2 1 2 1]\n [2 2 2 8 2 0 0 2 2 1 1 1]\n [2 8 2 2 2 2 0 2 2 2 2 2]\n [2 2 2 2 2 2 2 2 2 2 2 2]\n [2 2 2 2 2 2 2 2 2 2 2 2]\n [2 2 2 2 2 2 2 0 0 0 2 2]\n [2 2 2 2 2 2 2 2 2 2 2 2]]"}, {"id": "197", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "198", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "200", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "201", "type": "val", "name": "y", "val": "2"}, {"id": "203", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "204", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "206", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "207", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "209", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "210", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "212", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "213", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "215", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "216", "type": "val", "name": "y", "val": "3"}, {"id": "218", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "219", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "221", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "222", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "224", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "225", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "227", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "228", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "230", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "231", "type": "val", "name": "y", "val": "4"}, {"id": "233", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "234", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "236", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "237", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "239", "type": "val", "name": "output_grid", "val": "[[2 2 2 2 2 2 2 2 2 1 1 1]\n [2 2 8 8 3 3 2 2 2 1 2 1]\n [2 2 2 8 3 2 2 2 2 1 1 1]\n [2 8 2 2 3 3 2 2 2 2 2 2]\n [2 2 2 2 2 2 2 2 2 2 2 2]\n [2 2 2 2 2 2 2 2 2 2 2 2]\n [2 2 2 2 2 2 2 0 0 0 2 2]\n [2 2 2 2 2 2 2 2 2 2 2 2]]"}, {"id": "241", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "242", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "244", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "245", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "247", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "248", "type": "val", "name": "y", "val": "5"}, {"id": "250", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "251", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "253", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "254", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "256", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "257", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "259", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "260", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "262", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "263", "type": "val", "name": "y", "val": "6"}, {"id": "265", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "266", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "268", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "269", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "271", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "272", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "274", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "275", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "277", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "278", "type": "val", "name": "y", "val": "7"}, {"id": "280", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "281", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "283", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "284", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "286", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "287", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "289", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "290", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "292", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "293", "type": "val", "name": "y", "val": "8"}, {"id": "295", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "296", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "298", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "299", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "301", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "302", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "304", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "305", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "307", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "308", "type": "val", "name": "y", "val": "9"}, {"id": "310", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "311", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "313", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "314", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "316", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "317", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "319", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "320", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "322", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "323", "type": "val", "name": "x", "val": "2"}, {"id": "324", "type": "val", "name": "y", "val": "0"}, {"id": "326", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "327", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "329", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "330", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "332", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "333", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "335", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "336", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "338", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "339", "type": "val", "name": "y", "val": "1"}, {"id": "341", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "342", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "344", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "345", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "347", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "348", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "350", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "351", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "353", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "354", "type": "val", "name": "y", "val": "2"}, {"id": "356", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "357", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "359", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "360", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "362", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "363", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "365", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "366", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "368", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "369", "type": "val", "name": "y", "val": "3"}, {"id": "371", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "372", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "374", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "375", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "377", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "378", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "380", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "381", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "383", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "384", "type": "val", "name": "y", "val": "4"}, {"id": "386", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "387", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "389", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "390", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "392", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "393", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "395", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "396", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "398", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "399", "type": "val", "name": "y", "val": "5"}, {"id": "401", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "402", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "404", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "405", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "407", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "408", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "410", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "411", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "413", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "414", "type": "val", "name": "y", "val": "6"}, {"id": "416", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "417", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "419", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "420", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "422", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "423", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "425", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "426", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "428", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "429", "type": "val", "name": "y", "val": "7"}, {"id": "431", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "432", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "434", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "435", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "437", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "438", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "440", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "441", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "443", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "444", "type": "val", "name": "y", "val": "8"}, {"id": "446", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "447", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "449", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "450", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "452", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "453", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "455", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "456", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "458", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "459", "type": "val", "name": "y", "val": "9"}, {"id": "461", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "462", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "464", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "465", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "467", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "468", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "470", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "471", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "473", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "474", "type": "val", "name": "x", "val": "3"}, {"id": "475", "type": "val", "name": "y", "val": "0"}, {"id": "477", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "478", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "480", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "481", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "483", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "484", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "486", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "487", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "489", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "490", "type": "val", "name": "y", "val": "1"}, {"id": "492", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "493", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "495", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "496", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "498", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "499", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "501", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "502", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "504", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "505", "type": "val", "name": "y", "val": "2"}, {"id": "507", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "508", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "510", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "511", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "513", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "514", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "516", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "517", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "519", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "520", "type": "val", "name": "y", "val": "3"}, {"id": "522", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "523", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "525", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "526", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "528", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "529", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "531", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "532", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "534", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "535", "type": "val", "name": "y", "val": "4"}, {"id": "537", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "538", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "540", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "541", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "543", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "544", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "546", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "547", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "549", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "550", "type": "val", "name": "y", "val": "5"}, {"id": "552", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "553", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "555", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "556", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "558", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "559", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "561", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "562", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "564", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "565", "type": "val", "name": "y", "val": "6"}, {"id": "567", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "568", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "570", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "571", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "573", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "574", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "576", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "577", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "579", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "580", "type": "val", "name": "y", "val": "7"}, {"id": "582", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "583", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "585", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "586", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "588", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "589", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "591", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "592", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "594", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "595", "type": "val", "name": "y", "val": "8"}, {"id": "597", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "598", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "600", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "601", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "603", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "604", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "606", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "607", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "609", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "610", "type": "val", "name": "y", "val": "9"}, {"id": "612", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "613", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "615", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "616", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "618", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "619", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "621", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "622", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "624", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "625", "type": "val", "name": "x", "val": "4"}, {"id": "626", "type": "val", "name": "y", "val": "0"}, {"id": "628", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "629", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "631", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "632", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "634", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "635", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "637", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "638", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "640", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "641", "type": "val", "name": "y", "val": "1"}, {"id": "643", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "644", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "646", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "647", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "649", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "650", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "652", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "653", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "655", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "656", "type": "val", "name": "y", "val": "2"}, {"id": "658", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "659", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "661", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "662", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "664", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "665", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "667", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "668", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "670", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "671", "type": "val", "name": "y", "val": "3"}, {"id": "673", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "674", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "676", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "677", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "679", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "680", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "682", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "683", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "685", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "686", "type": "val", "name": "y", "val": "4"}, {"id": "688", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "689", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "691", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "692", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "694", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "695", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "697", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "698", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "700", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "701", "type": "val", "name": "y", "val": "5"}, {"id": "703", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "704", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "706", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "707", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "709", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "710", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "712", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "713", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "715", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "716", "type": "val", "name": "y", "val": "6"}, {"id": "718", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "719", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "721", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "722", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "724", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "725", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "727", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "728", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "730", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "731", "type": "val", "name": "y", "val": "7"}, {"id": "733", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "734", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "736", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "737", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "739", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "740", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "742", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "743", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "745", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "746", "type": "val", "name": "y", "val": "8"}, {"id": "748", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "749", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "751", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "752", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "754", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "755", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "757", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "758", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "760", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "761", "type": "val", "name": "y", "val": "9"}, {"id": "763", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "764", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "766", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "767", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "769", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "770", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "772", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "773", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "775", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "776", "type": "val", "name": "x", "val": "5"}, {"id": "777", "type": "val", "name": "y", "val": "0"}, {"id": "779", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "780", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "782", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "783", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "785", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "786", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "788", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "789", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "791", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "792", "type": "val", "name": "y", "val": "1"}, {"id": "794", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "795", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "797", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "798", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "800", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "801", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "803", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "804", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "806", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "807", "type": "val", "name": "y", "val": "2"}, {"id": "809", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "810", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "812", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "813", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "815", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "816", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "818", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "819", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "821", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "822", "type": "val", "name": "y", "val": "3"}, {"id": "824", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "825", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "827", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "828", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "830", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "831", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "833", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "834", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "836", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "837", "type": "val", "name": "y", "val": "4"}, {"id": "839", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "840", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "842", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "843", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "845", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "846", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "848", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "849", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "851", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "852", "type": "val", "name": "y", "val": "5"}, {"id": "854", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "855", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "857", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "858", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "860", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "861", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "863", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "864", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "866", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "867", "type": "val", "name": "y", "val": "6"}, {"id": "869", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "870", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "872", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "873", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "875", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "876", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "878", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "879", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "881", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "882", "type": "val", "name": "y", "val": "7"}, {"id": "884", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "885", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "887", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "888", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "890", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "891", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "893", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "894", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "896", "type": "val", "name": "output_grid", "val": "[[2 2 2 2 2 2 2 2 2 1 1 1]\n [2 2 8 8 3 3 2 2 2 1 2 1]\n [2 2 2 8 3 2 2 2 2 1 1 1]\n [2 8 2 2 3 3 2 2 2 2 2 2]\n [2 2 2 2 2 2 2 2 2 2 2 2]\n [2 2 2 2 2 2 2 4 4 4 2 2]\n [2 2 2 2 2 2 2 2 2 2 2 2]\n [2 2 2 2 2 2 2 4 4 4 2 2]]"}, {"id": "898", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "899", "type": "val", "name": "y", "val": "8"}, {"id": "901", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "902", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "904", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "905", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "907", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "908", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "910", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "911", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "913", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "914", "type": "val", "name": "y", "val": "9"}, {"id": "916", "type": "val", "name": "square", "val": "[[1 1 1]\n [1 2 1]\n [1 1 1]]"}, {"id": "917", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "919", "type": "val", "name": "square", "val": "[[2 3 3]\n [2 2 3]\n [2 3 3]]"}, {"id": "920", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "922", "type": "val", "name": "square", "val": "[[8 8 2]\n [8 2 2]\n [2 2 8]]"}, {"id": "923", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "925", "type": "val", "name": "square", "val": "[[4 2 4]\n [4 2 4]\n [4 2 4]]"}, {"id": "926", "type": "stmt", "val": "`for all pixels in grid1, if it is red, then the pixel in grid2 of same position mustn't be red. If it is black, then the pixel in grid2 of same position must be red. if for all pixels, the previous rule is true, return true, else return false`_and_color(output_grid, x, y, square)"}, {"id": "928", "type": "stmt", "val": "for (x, y) in `return all left top coordinates of 3x3 grids in the grid`(output_grid):"}, {"id": "929", "type": "stmt", "val": "return output_grid"}], "edges": [["0", "1"], ["1", "2"], ["2", "3"], ["0", "3"], ["3", "4"], ["4", "5"], ["0", "5"], ["0", "7"], ["4", "7"], ["7", "8"], ["8", "9"], ["9", "10"], ["9", "11"], ["10", "12"], ["11", "12"], ["8", "12"], ["12", "13"], ["13", "14"], ["14", "15"], ["14", "16"], ["13", "19"], ["15", "19"], ["18", "19"], ["16", "19"], ["13", "22"], ["15", "22"], ["21", "22"], ["16", "22"], ["13", "25"], ["15", "25"], ["24", "25"], ["16", "25"], ["13", "28"], ["15", "28"], ["27", "28"], ["16", "28"], ["13", "30"], ["16", "30"], ["15", "30"], ["30", "31"], ["13", "34"], ["15", "34"], ["33", "34"], ["31", "34"], ["13", "37"], ["15", "37"], ["36", "37"], ["31", "37"], ["13", "40"], ["15", "40"], ["39", "40"], ["31", "40"], ["13", "43"], ["15", "43"], ["42", "43"], ["31", "43"], ["13", "45"], ["31", "45"], ["15", "45"], ["45", "46"], ["13", "49"], ["15", "49"], ["48", "49"], ["46", "49"], ["13", "52"], ["15", "52"], ["51", "52"], ["46", "52"], ["13", "55"], ["15", "55"], ["54", "55"], ["46", "55"], ["13", "58"], ["15", "58"], ["57", "58"], ["46", "58"], ["13", "60"], ["46", "60"], ["15", "60"], ["60", "61"], ["13", "64"], ["15", "64"], ["63", "64"], ["61", "64"], ["13", "67"], ["15", "67"], ["66", "67"], ["61", "67"], ["13", "70"], ["15", "70"], ["69", "70"], ["61", "70"], ["13", "73"], ["15", "73"], ["72", "73"], ["61", "73"], ["13", "75"], ["61", "75"], ["15", "75"], ["75", "76"], ["13", "79"], ["15", "79"], ["78", "79"], ["76", "79"], ["13", "82"], ["15", "82"], ["81", "82"], ["76", "82"], ["13", "85"], ["15", "85"], ["84", "85"], ["76", "85"], ["13", "88"], ["15", "88"], ["87", "88"], ["76", "88"], ["13", "90"], ["76", "90"], ["15", "90"], ["90", "91"], ["13", "94"], ["15", "94"], ["93", "94"], ["91", "94"], ["13", "97"], ["15", "97"], ["96", "97"], ["91", "97"], ["13", "100"], ["15", "100"], ["99", "100"], ["91", "100"], ["13", "103"], ["15", "103"], ["102", "103"], ["91", "103"], ["13", "105"], ["91", "105"], ["15", "105"], ["105", "106"], ["13", "109"], ["15", "109"], ["108", "109"], ["106", "109"], ["13", "112"], ["15", "112"], ["111", "112"], ["106", "112"], ["13", "115"], ["15", "115"], ["114", "115"], ["106", "115"], ["13", "118"], ["15", "118"], ["117", "118"], ["106", "118"], ["13", "120"], ["106", "120"], ["15", "120"], ["120", "121"], ["13", "124"], ["15", "124"], ["123", "124"], ["121", "124"], ["13", "127"], ["15", "127"], ["126", "127"], ["121", "127"], ["13", "130"], ["15", "130"], ["129", "130"], ["121", "130"], ["13", "133"], ["15", "133"], ["132", "133"], ["121", "133"], ["13", "135"], ["121", "135"], ["15", "135"], ["135", "136"], ["13", "139"], ["15", "139"], ["138", "139"], ["136", "139"], ["13", "142"], ["15", "142"], ["141", "142"], ["136", "142"], ["13", "145"], ["15", "145"], ["144", "145"], ["136", "145"], ["13", "148"], ["15", "148"], ["147", "148"], ["136", "148"], ["13", "150"], ["136", "150"], ["15", "150"], ["150", "151"], ["13", "154"], ["15", "154"], ["153", "154"], ["151", "154"], ["154", "156"], ["156", "159"], ["15", "159"], ["158", "159"], ["151", "159"], ["156", "162"], ["15", "162"], ["161", "162"], ["151", "162"], ["156", "165"], ["15", "165"], ["164", "165"], ["151", "165"], ["156", "167"], ["151", "167"], ["15", "167"], ["167", "168"], ["167", "169"], ["156", "172"], ["168", "172"], ["171", "172"], ["169", "172"], ["156", "175"], ["168", "175"], ["174", "175"], ["169", "175"], ["156", "178"], ["168", "178"], ["177", "178"], ["169", "178"], ["156", "181"], ["168", "181"], ["180", "181"], ["169", "181"], ["156", "183"], ["169", "183"], ["168", "183"], ["183", "184"], ["156", "187"], ["168", "187"], ["186", "187"], ["184", "187"], ["156", "190"], ["168", "190"], ["189", "190"], ["184", "190"], ["156", "193"], ["168", "193"], ["192", "193"], ["184", "193"], ["193", "195"], ["195", "198"], ["168", "198"], ["197", "198"], ["184", "198"], ["195", "200"], ["184", "200"], ["168", "200"], ["200", "201"], ["195", "204"], ["168", "204"], ["203", "204"], ["201", "204"], ["195", "207"], ["168", "207"], ["206", "207"], ["201", "207"], ["195", "210"], ["168", "210"], ["209", "210"], ["201", "210"], ["195", "213"], ["168", "213"], ["212", "213"], ["201", "213"], ["195", "215"], ["201", "215"], ["168", "215"], ["215", "216"], ["195", "219"], ["168", "219"], ["218", "219"], ["216", "219"], ["195", "222"], ["168", "222"], ["221", "222"], ["216", "222"], ["195", "225"], ["168", "225"], ["224", "225"], ["216", "225"], ["195", "228"], ["168", "228"], ["227", "228"], ["216", "228"], ["195", "230"], ["216", "230"], ["168", "230"], ["230", "231"], ["195", "234"], ["168", "234"], ["233", "234"], ["231", "234"], ["195", "237"], ["168", "237"], ["236", "237"], ["231", "237"], ["237", "239"], ["239", "242"], ["168", "242"], ["241", "242"], ["231", "242"], ["239", "245"], ["168", "245"], ["244", "245"], ["231", "245"], ["239", "247"], ["231", "247"], ["168", "247"], ["247", "248"], ["239", "251"], ["168", "251"], ["250", "251"], ["248", "251"], ["239", "254"], ["168", "254"], ["253", "254"], ["248", "254"], ["239", "257"], ["168", "257"], ["256", "257"], ["248", "257"], ["239", "260"], ["168", "260"], ["259", "260"], ["248", "260"], ["239", "262"], ["248", "262"], ["168", "262"], ["262", "263"], ["239", "266"], ["168", "266"], ["265", "266"], ["263", "266"], ["239", "269"], ["168", "269"], ["268", "269"], ["263", "269"], ["239", "272"], ["168", "272"], ["271", "272"], ["263", "272"], ["239", "275"], ["168", "275"], ["274", "275"], ["263", "275"], ["239", "277"], ["263", "277"], ["168", "277"], ["277", "278"], ["239", "281"], ["168", "281"], ["280", "281"], ["278", "281"], ["239", "284"], ["168", "284"], ["283", "284"], ["278", "284"], ["239", "287"], ["168", "287"], ["286", "287"], ["278", "287"], ["239", "290"], ["168", "290"], ["289", "290"], ["278", "290"], ["239", "292"], ["278", "292"], ["168", "292"], ["292", "293"], ["239", "296"], ["168", "296"], ["295", "296"], ["293", "296"], ["239", "299"], ["168", "299"], ["298", "299"], ["293", "299"], ["239", "302"], ["168", "302"], ["301", "302"], ["293", "302"], ["239", "305"], ["168", "305"], ["304", "305"], ["293", "305"], ["239", "307"], ["293", "307"], ["168", "307"], ["307", "308"], ["239", "311"], ["168", "311"], ["310", "311"], ["308", "311"], ["239", "314"], ["168", "314"], ["313", "314"], ["308", "314"], ["239", "317"], ["168", "317"], ["316", "317"], ["308", "317"], ["239", "320"], ["168", "320"], ["319", "320"], ["308", "320"], ["239", "322"], ["308", "322"], ["168", "322"], ["322", "323"], ["322", "324"], ["239", "327"], ["323", "327"], ["326", "327"], ["324", "327"], ["239", "330"], ["323", "330"], ["329", "330"], ["324", "330"], ["239", "333"], ["323", "333"], ["332", "333"], ["324", "333"], ["239", "336"], ["323", "336"], ["335", "336"], ["324", "336"], ["239", "338"], ["324", "338"], ["323", "338"], ["338", "339"], ["239", "342"], ["323", "342"], ["341", "342"], ["339", "342"], ["239", "345"], ["323", "345"], ["344", "345"], ["339", "345"], ["239", "348"], ["323", "348"], ["347", "348"], ["339", "348"], ["239", "351"], ["323", "351"], ["350", "351"], ["339", "351"], ["239", "353"], ["339", "353"], ["323", "353"], ["353", "354"], ["239", "357"], ["323", "357"], ["356", "357"], ["354", "357"], ["239", "360"], ["323", "360"], ["359", "360"], ["354", "360"], ["239", "363"], ["323", "363"], ["362", "363"], ["354", "363"], ["239", "366"], ["323", "366"], ["365", "366"], ["354", "366"], ["239", "368"], ["354", "368"], ["323", "368"], ["368", "369"], ["239", "372"], ["323", "372"], ["371", "372"], ["369", "372"], ["239", "375"], ["323", "375"], ["374", "375"], ["369", "375"], ["239", "378"], ["323", "378"], ["377", "378"], ["369", "378"], ["239", "381"], ["323", "381"], ["380", "381"], ["369", "381"], ["239", "383"], ["369", "383"], ["323", "383"], ["383", "384"], ["239", "387"], ["323", "387"], ["386", "387"], ["384", "387"], ["239", "390"], ["323", "390"], ["389", "390"], ["384", "390"], ["239", "393"], ["323", "393"], ["392", "393"], ["384", "393"], ["239", "396"], ["323", "396"], ["395", "396"], ["384", "396"], ["239", "398"], ["384", "398"], ["323", "398"], ["398", "399"], ["239", "402"], ["323", "402"], ["401", "402"], ["399", "402"], ["239", "405"], ["323", "405"], ["404", "405"], ["399", "405"], ["239", "408"], ["323", "408"], ["407", "408"], ["399", "408"], ["239", "411"], ["323", "411"], ["410", "411"], ["399", "411"], ["239", "413"], ["399", "413"], ["323", "413"], ["413", "414"], ["239", "417"], ["323", "417"], ["416", "417"], ["414", "417"], ["239", "420"], ["323", "420"], ["419", "420"], ["414", "420"], ["239", "423"], ["323", "423"], ["422", "423"], ["414", "423"], ["239", "426"], ["323", "426"], ["425", "426"], ["414", "426"], ["239", "428"], ["414", "428"], ["323", "428"], ["428", "429"], ["239", "432"], ["323", "432"], ["431", "432"], ["429", "432"], ["239", "435"], ["323", "435"], ["434", "435"], ["429", "435"], ["239", "438"], ["323", "438"], ["437", "438"], ["429", "438"], ["239", "441"], ["323", "441"], ["440", "441"], ["429", "441"], ["239", "443"], ["429", "443"], ["323", "443"], ["443", "444"], ["239", "447"], ["323", "447"], ["446", "447"], ["444", "447"], ["239", "450"], ["323", "450"], ["449", "450"], ["444", "450"], ["239", "453"], ["323", "453"], ["452", "453"], ["444", "453"], ["239", "456"], ["323", "456"], ["455", "456"], ["444", "456"], ["239", "458"], ["444", "458"], ["323", "458"], ["458", "459"], ["239", "462"], ["323", "462"], ["461", "462"], ["459", "462"], ["239", "465"], ["323", "465"], ["464", "465"], ["459", "465"], ["239", "468"], ["323", "468"], ["467", "468"], ["459", "468"], ["239", "471"], ["323", "471"], ["470", "471"], ["459", "471"], ["239", "473"], ["459", "473"], ["323", "473"], ["473", "474"], ["473", "475"], ["239", "478"], ["474", "478"], ["477", "478"], ["475", "478"], ["239", "481"], ["474", "481"], ["480", "481"], ["475", "481"], ["239", "484"], ["474", "484"], ["483", "484"], ["475", "484"], ["239", "487"], ["474", "487"], ["486", "487"], ["475", "487"], ["239", "489"], ["475", "489"], ["474", "489"], ["489", "490"], ["239", "493"], ["474", "493"], ["492", "493"], ["490", "493"], ["239", "496"], ["474", "496"], ["495", "496"], ["490", "496"], ["239", "499"], ["474", "499"], ["498", "499"], ["490", "499"], ["239", "502"], ["474", "502"], ["501", "502"], ["490", "502"], ["239", "504"], ["490", "504"], ["474", "504"], ["504", "505"], ["239", "508"], ["474", "508"], ["507", "508"], ["505", "508"], ["239", "511"], ["474", "511"], ["510", "511"], ["505", "511"], ["239", "514"], ["474", "514"], ["513", "514"], ["505", "514"], ["239", "517"], ["474", "517"], ["516", "517"], ["505", "517"], ["239", "519"], ["505", "519"], ["474", "519"], ["519", "520"], ["239", "523"], ["474", "523"], ["522", "523"], ["520", "523"], ["239", "526"], ["474", "526"], ["525", "526"], ["520", "526"], ["239", "529"], ["474", "529"], ["528", "529"], ["520", "529"], ["239", "532"], ["474", "532"], ["531", "532"], ["520", "532"], ["239", "534"], ["520", "534"], ["474", "534"], ["534", "535"], ["239", "538"], ["474", "538"], ["537", "538"], ["535", "538"], ["239", "541"], ["474", "541"], ["540", "541"], ["535", "541"], ["239", "544"], ["474", "544"], ["543", "544"], ["535", "544"], ["239", "547"], ["474", "547"], ["546", "547"], ["535", "547"], ["239", "549"], ["535", "549"], ["474", "549"], ["549", "550"], ["239", "553"], ["474", "553"], ["552", "553"], ["550", "553"], ["239", "556"], ["474", "556"], ["555", "556"], ["550", "556"], ["239", "559"], ["474", "559"], ["558", "559"], ["550", "559"], ["239", "562"], ["474", "562"], ["561", "562"], ["550", "562"], ["239", "564"], ["550", "564"], ["474", "564"], ["564", "565"], ["239", "568"], ["474", "568"], ["567", "568"], ["565", "568"], ["239", "571"], ["474", "571"], ["570", "571"], ["565", "571"], ["239", "574"], ["474", "574"], ["573", "574"], ["565", "574"], ["239", "577"], ["474", "577"], ["576", "577"], ["565", "577"], ["239", "579"], ["565", "579"], ["474", "579"], ["579", "580"], ["239", "583"], ["474", "583"], ["582", "583"], ["580", "583"], ["239", "586"], ["474", "586"], ["585", "586"], ["580", "586"], ["239", "589"], ["474", "589"], ["588", "589"], ["580", "589"], ["239", "592"], ["474", "592"], ["591", "592"], ["580", "592"], ["239", "594"], ["580", "594"], ["474", "594"], ["594", "595"], ["239", "598"], ["474", "598"], ["597", "598"], ["595", "598"], ["239", "601"], ["474", "601"], ["600", "601"], ["595", "601"], ["239", "604"], ["474", "604"], ["603", "604"], ["595", "604"], ["239", "607"], ["474", "607"], ["606", "607"], ["595", "607"], ["239", "609"], ["595", "609"], ["474", "609"], ["609", "610"], ["239", "613"], ["474", "613"], ["612", "613"], ["610", "613"], ["239", "616"], ["474", "616"], ["615", "616"], ["610", "616"], ["239", "619"], ["474", "619"], ["618", "619"], ["610", "619"], ["239", "622"], ["474", "622"], ["621", "622"], ["610", "622"], ["239", "624"], ["610", "624"], ["474", "624"], ["624", "625"], ["624", "626"], ["239", "629"], ["625", "629"], ["628", "629"], ["626", "629"], ["239", "632"], ["625", "632"], ["631", "632"], ["626", "632"], ["239", "635"], ["625", "635"], ["634", "635"], ["626", "635"], ["239", "638"], ["625", "638"], ["637", "638"], ["626", "638"], ["239", "640"], ["626", "640"], ["625", "640"], ["640", "641"], ["239", "644"], ["625", "644"], ["643", "644"], ["641", "644"], ["239", "647"], ["625", "647"], ["646", "647"], ["641", "647"], ["239", "650"], ["625", "650"], ["649", "650"], ["641", "650"], ["239", "653"], ["625", "653"], ["652", "653"], ["641", "653"], ["239", "655"], ["641", "655"], ["625", "655"], ["655", "656"], ["239", "659"], ["625", "659"], ["658", "659"], ["656", "659"], ["239", "662"], ["625", "662"], ["661", "662"], ["656", "662"], ["239", "665"], ["625", "665"], ["664", "665"], ["656", "665"], ["239", "668"], ["625", "668"], ["667", "668"], ["656", "668"], ["239", "670"], ["656", "670"], ["625", "670"], ["670", "671"], ["239", "674"], ["625", "674"], ["673", "674"], ["671", "674"], ["239", "677"], ["625", "677"], ["676", "677"], ["671", "677"], ["239", "680"], ["625", "680"], ["679", "680"], ["671", "680"], ["239", "683"], ["625", "683"], ["682", "683"], ["671", "683"], ["239", "685"], ["671", "685"], ["625", "685"], ["685", "686"], ["239", "689"], ["625", "689"], ["688", "689"], ["686", "689"], ["239", "692"], ["625", "692"], ["691", "692"], ["686", "692"], ["239", "695"], ["625", "695"], ["694", "695"], ["686", "695"], ["239", "698"], ["625", "698"], ["697", "698"], ["686", "698"], ["239", "700"], ["686", "700"], ["625", "700"], ["700", "701"], ["239", "704"], ["625", "704"], ["703", "704"], ["701", "704"], ["239", "707"], ["625", "707"], ["706", "707"], ["701", "707"], ["239", "710"], ["625", "710"], ["709", "710"], ["701", "710"], ["239", "713"], ["625", "713"], ["712", "713"], ["701", "713"], ["239", "715"], ["701", "715"], ["625", "715"], ["715", "716"], ["239", "719"], ["625", "719"], ["718", "719"], ["716", "719"], ["239", "722"], ["625", "722"], ["721", "722"], ["716", "722"], ["239", "725"], ["625", "725"], ["724", "725"], ["716", "725"], ["239", "728"], ["625", "728"], ["727", "728"], ["716", "728"], ["239", "730"], ["716", "730"], ["625", "730"], ["730", "731"], ["239", "734"], ["625", "734"], ["733", "734"], ["731", "734"], ["239", "737"], ["625", "737"], ["736", "737"], ["731", "737"], ["239", "740"], ["625", "740"], ["739", "740"], ["731", "740"], ["239", "743"], ["625", "743"], ["742", "743"], ["731", "743"], ["239", "745"], ["731", "745"], ["625", "745"], ["745", "746"], ["239", "749"], ["625", "749"], ["748", "749"], ["746", "749"], ["239", "752"], ["625", "752"], ["751", "752"], ["746", "752"], ["239", "755"], ["625", "755"], ["754", "755"], ["746", "755"], ["239", "758"], ["625", "758"], ["757", "758"], ["746", "758"], ["239", "760"], ["746", "760"], ["625", "760"], ["760", "761"], ["239", "764"], ["625", "764"], ["763", "764"], ["761", "764"], ["239", "767"], ["625", "767"], ["766", "767"], ["761", "767"], ["239", "770"], ["625", "770"], ["769", "770"], ["761", "770"], ["239", "773"], ["625", "773"], ["772", "773"], ["761", "773"], ["239", "775"], ["761", "775"], ["625", "775"], ["775", "776"], ["775", "777"], ["239", "780"], ["776", "780"], ["779", "780"], ["777", "780"], ["239", "783"], ["776", "783"], ["782", "783"], ["777", "783"], ["239", "786"], ["776", "786"], ["785", "786"], ["777", "786"], ["239", "789"], ["776", "789"], ["788", "789"], ["777", "789"], ["239", "791"], ["777", "791"], ["776", "791"], ["791", "792"], ["239", "795"], ["776", "795"], ["794", "795"], ["792", "795"], ["239", "798"], ["776", "798"], ["797", "798"], ["792", "798"], ["239", "801"], ["776", "801"], ["800", "801"], ["792", "801"], ["239", "804"], ["776", "804"], ["803", "804"], ["792", "804"], ["239", "806"], ["792", "806"], ["776", "806"], ["806", "807"], ["239", "810"], ["776", "810"], ["809", "810"], ["807", "810"], ["239", "813"], ["776", "813"], ["812", "813"], ["807", "813"], ["239", "816"], ["776", "816"], ["815", "816"], ["807", "816"], ["239", "819"], ["776", "819"], ["818", "819"], ["807", "819"], ["239", "821"], ["807", "821"], ["776", "821"], ["821", "822"], ["239", "825"], ["776", "825"], ["824", "825"], ["822", "825"], ["239", "828"], ["776", "828"], ["827", "828"], ["822", "828"], ["239", "831"], ["776", "831"], ["830", "831"], ["822", "831"], ["239", "834"], ["776", "834"], ["833", "834"], ["822", "834"], ["239", "836"], ["822", "836"], ["776", "836"], ["836", "837"], ["239", "840"], ["776", "840"], ["839", "840"], ["837", "840"], ["239", "843"], ["776", "843"], ["842", "843"], ["837", "843"], ["239", "846"], ["776", "846"], ["845", "846"], ["837", "846"], ["239", "849"], ["776", "849"], ["848", "849"], ["837", "849"], ["239", "851"], ["837", "851"], ["776", "851"], ["851", "852"], ["239", "855"], ["776", "855"], ["854", "855"], ["852", "855"], ["239", "858"], ["776", "858"], ["857", "858"], ["852", "858"], ["239", "861"], ["776", "861"], ["860", "861"], ["852", "861"], ["239", "864"], ["776", "864"], ["863", "864"], ["852", "864"], ["239", "866"], ["852", "866"], ["776", "866"], ["866", "867"], ["239", "870"], ["776", "870"], ["869", "870"], ["867", "870"], ["239", "873"], ["776", "873"], ["872", "873"], ["867", "873"], ["239", "876"], ["776", "876"], ["875", "876"], ["867", "876"], ["239", "879"], ["776", "879"], ["878", "879"], ["867", "879"], ["239", "881"], ["867", "881"], ["776", "881"], ["881", "882"], ["239", "885"], ["776", "885"], ["884", "885"], ["882", "885"], ["239", "888"], ["776", "888"], ["887", "888"], ["882", "888"], ["239", "891"], ["776", "891"], ["890", "891"], ["882", "891"], ["239", "894"], ["776", "894"], ["893", "894"], ["882", "894"], ["894", "896"], ["896", "898"], ["882", "898"], ["776", "898"], ["898", "899"], ["896", "902"], ["776", "902"], ["901", "902"], ["899", "902"], ["896", "905"], ["776", "905"], ["904", "905"], ["899", "905"], ["896", "908"], ["776", "908"], ["907", "908"], ["899", "908"], ["896", "911"], ["776", "911"], ["910", "911"], ["899", "911"], ["896", "913"], ["899", "913"], ["776", "913"], ["913", "914"], ["896", "917"], ["776", "917"], ["916", "917"], ["914", "917"], ["896", "920"], ["776", "920"], ["919", "920"], ["914", "920"], ["896", "923"], ["776", "923"], ["922", "923"], ["914", "923"], ["896", "926"], ["776", "926"], ["925", "926"], ["914", "926"], ["896", "928"], ["914", "928"], ["776", "928"], ["896", "929"]]}